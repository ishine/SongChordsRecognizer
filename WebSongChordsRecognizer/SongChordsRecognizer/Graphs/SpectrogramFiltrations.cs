using SongChordsRecognizer.MusicFeatures;
using System;
using System.Collections.Generic;

namespace SongChordsRecognizer.Graphs
{
    #region Interfaces

    /// <summary>
    /// Interface for all Spectrogram filter functions. 
    /// Each of Filtration should contain function 'Filter' that returns
    /// filtered spectrogram from from misleading informations.
    /// </summary>
    public interface ISpectrogramFiltration
    {
        /// <summary>
        /// An algorithm that filters spectrogram data from misleading informations in some way.
        /// </summary>
        /// <param name="spectrogram">Spectrogram with generated spectrogram data.</param>
        /// <returns>Filtered spectrogram by specific algorithm.</returns>
        public double[][] Filter(Spectrogram spectrogram);
    }



    #endregion


    #region Spectrogram Filtrations

    /// <summary>
    /// This algorithm filter spectrogram from nth harmonics which are generated by instruments.
    /// That means that if the tone of frequency F is played, then it is also reflected on frequencies 'F*n' for n = 1,2,3,....
    /// This filtration takes the minimum of spectrogram[i][j * n]* (1/epsilon)^{n-1} for n = 1,2,3,...,n_harmonics.
    /// By default epsilon=0.4 and n_harmonics=10.
    /// ( [Gomez 2006] Tonal description of polyphonic audio for music content processing. )
    /// </summary>
    public class FilterNthHarmonics : ISpectrogramFiltration
    {
        private double epsilon = 0.4;

        private double n_harmonics = 10;


        public double[][] Filter(Spectrogram spectrogram)
        {
            double[][] spectrogramData = spectrogram.GetData();
            double[][] filteredSpectrogram = new double[spectrogramData.Length][];

            for(int i = 0; i < spectrogramData.Length; i++)
            {
                filteredSpectrogram[i] = new double[spectrogramData[i].Length];
                for (int j = 0; j < spectrogramData[i].Length; j++)
                {
                    filteredSpectrogram[i][j] = MinOfHarmonics(spectrogramData[i], j);
                }
            }
            return filteredSpectrogram;
        }

        private double MinOfHarmonics(double[] spectrogramSample, int index)
        {
            double min = Math.Abs(spectrogramSample[index]);
            for(int i = 2; i <= n_harmonics && i * index < spectrogramSample.Length; i++)
            {
                if(min > Math.Abs(Math.Pow((1/epsilon), index-1) * spectrogramSample[index*i])) min = Math.Abs(Math.Pow((1 / epsilon), index - 1) * spectrogramSample[index * i]);
            }
            return min;
        }
    }



    /// <summary>
    /// ISpectrogramFiltration that doesn't do any of filtration. It will just return spectrogramData. 
    /// </summary>
    public class Identity : ISpectrogramFiltration
    {
        public double[][] Filter(Spectrogram spectrogram)
        {
            return spectrogram.GetData();
        }
    }



    /// <summary>
    /// When we are interested only in the chord recognition, there is only one area of tones that is
    /// intendet to accompaniment creation (in other words .. to harmony creation). That area begins cca
    /// at the end of the Great octave, and the area ends cca at the middle of the One lined octave.
    /// This filtration create a mask for that area, lets the values of that area same. The rest of the frequencies
    /// will be set on zero. 
    /// </summary>
    public class AccompanimentFrequencyAreaMask : ISpectrogramFiltration
    {
        private double l_frequency_border = 123.47; // Great B

        private double r_frequency_border = 349.23; // One-lined F

        public double[][] Filter(Spectrogram spectrogram)
        {
            double[][] spectrogramData = spectrogram.GetData();
            double[][] filteredSpectrogram = new double[spectrogramData.Length][];

            for (int i = 0; i < spectrogramData.Length; i++)
            {
                filteredSpectrogram[i] = new double[spectrogramData[i].Length];
                for (int j = 0; j < spectrogramData[i].Length; j++)
                {
                    if(((j / spectrogram.FrequencyToBinConst) >= l_frequency_border) && ((j / spectrogram.FrequencyToBinConst) <= r_frequency_border))
                    {
                        filteredSpectrogram[i][j] = Math.Abs(spectrogramData[i][j]);
                    }
                    else
                    {
                        filteredSpectrogram[i][j] = 0;
                    }
                }
            }
            return filteredSpectrogram;
        }
    }



    /// <summary>
    /// Basically, we have three (four) types of tones: 
    ///     0) Beats, ect..
    ///     1) Bass
    ///     2) Harmony
    ///     3) Melody
    /// (1) Bass tones are very interesting for chord, because it always specifies the root tone of chord.
    /// But sometimes these tones could be misleading, for instance in much more complex basslines like walking bass in Jazz, ect...
    /// (2) Harmony is the most interesing area. That area directly represents Chords. 
    /// (3) Melody is not that interesting for single chords. There could be passages that are not part of our chord. On the other hand,
    /// the melody is always based on a harmony. 
    /// 
    /// So it is a good idea to weight single octave tones by their "chord importance". For instance, great, small and one lined octaves are
    /// much more important than the rest of them.
    /// </summary>
    public class WeightedOctaves : ISpectrogramFiltration
    {
        private Dictionary<int, double> weights = new Dictionary<int, double> {
            {0, 0.01}, // Sub-contra
            {1, 0.01}, // Contra
            {2, 0.1}, // Great
            {3, 1}, // Small
            {4, 0.5}, // One lined
            {5, 0.01}, // Two lined
            {6, 0.01}, // Three lined
            {7, 0.01}, // Four lined
            {8, 0.01}, // Five lined
        };

        public double[][] Filter(Spectrogram spectrogram)
        {
            double[][] spectrogramData = spectrogram.GetData();
            double[][] filteredSpectrogram = new double[spectrogramData.Length][];
            List<Tone> tones = TonesGenerator.GetListOfTones();

            for (int i = 0; i < spectrogramData.Length; i++)
            {
                int tone_pointer = 0;
                filteredSpectrogram[i] = new double[spectrogramData[i].Length];
                for (int j = 0; j < spectrogramData[i].Length; j++)
                {
                    while (tone_pointer < tones.Count && tones[tone_pointer].R_FreqBorder < j / spectrogram.FrequencyToBinConst) { tone_pointer++; }

                    if (! (tone_pointer == tones.Count || tones[tone_pointer].L_FreqBorder > j / spectrogram.FrequencyToBinConst) )
                    {
                        filteredSpectrogram[i][j] = spectrogramData[i][j] * weights[tones[tone_pointer].Octave];
                    }
                    else
                    {
                        filteredSpectrogram[i][j] = 0;
                    }
                    
                }
            }
            return filteredSpectrogram;
        }


        public void SetWeight(int octave, double weight)
        {
            if (octave < 0 && octave > 8)
            {
                throw new Exception(ErrorMessages.ErrorMessages.SpectrogramFiltration_OctaveOutOfRange);
            }
            weights[octave] = weight;
        }
    }



    #endregion
}